public class A_TimeComplexity {

	public static void main(String[] args) {
		//알고리즘 선택의 기준이 되는 시간 복잡도
		//시간 복잡도의 개념을 이해함으로써 문제에 사용하여야 하는 알고리즘을 선택할 수 있다.
		//시간 복잡도는 주어진 문제를 해결하기 위한 연횟수를 말한다.
		//파이썬 프로그래밍에서는 2천만 ~ 1억 번의 연산을 1초의 수행 시간으로 예측할 수 있다.
		
		//시간 복잡도 유형 :
		// 1. 빅-오메가 : 최선일 때(best case)의 연산 횟수를 나타낸 표기법 -- 1
		// 2. 빅-세타 : 보통일 때(average case)의 연산 횟수를 나타낸 표기법 -- N / 2
		// 3. 빅-오 : 최악일 때(worst case)의 연산 횟수를 나타낸 표기법 -- N

		//코딩 테스트에서는 빅-오를 기준으로 수행 시간을 계산하라
		//-- 최악의 경우. N가지 경우수 중 N번째로 정답에 도달하는 경우를 의미한다.
		// 연산 횟수 = 알고리즘 시간 복잡도 n값의 최대값.
		// 시간 복잡도 : 버블 sort : N^2
		// 병합 sort : n * log(n)
		// ==> 버블 sort는 사용하면 안되겠구나!
		// 시간 복잡도를 바탕으로 코드 로직을 개선하자!
		// 1. 상수는 시간 복잡도 계산에서 제외한다.
		// 2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도 선정의 기준이 된다.

		// 예제 코드:1
//		int N = 10;
//		int cnt = 1;
//		
//		for(int i = 0; i < N; i++) {
//			System.out.println("연산 횟수 : " + cnt);
//			cnt +=1;
//		}

		// 예제 코드 2:
//		int N = 10;
//		int cnt = 1;
//		
//		for(int i = 0; i < N; i++) {
//			System.out.println("연산 횟수 : " + cnt);
//			cnt+=1;
//		}
//		System.out.println();
//		for(int i = 0; i < N; i++) {
//			System.out.println("연산 횟수 : " + cnt);
//			cnt+=1;
//		}
//		System.out.println();
//		for(int i = 0; i < N; i++) {
//			System.out.println("연산 횟수 : " + cnt);
//			cnt+=1;
//		}
		// 예제 코드 1과 2는 연산 횟수가 세 배나 차이가 나나,
		// 같은 시간 복잡도를 지니는 코드들이다.

		// 예제 코드 3: 연산 횟수가 N^2
		int N = 10;
		int cnt = 1;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				System.out.println("연산 횟수 : " + cnt);
				cnt += 1;
			}
		}
		// 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출한다.
		// 이에 1중 for문 100개 + 2중 for문 2개가 존재한다면
		// 시간 복잡도 기준은 2중 for문이 된다.

		// 시간 복잡도는 최악의 케이스를 상정하고 산정한다.
		// Big-O 기준. 가장 최대 크기 케이스(N)을 기준으로!
		// 시간 복잡도는 최대 중첩문을 기준으로 산정한다.
	}
}